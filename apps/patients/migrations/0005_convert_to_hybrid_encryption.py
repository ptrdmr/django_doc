# Generated by Django 5.2.3 on 2025-08-27 19:25

import json
import logging
from django.db import migrations
from django.utils import timezone

logger = logging.getLogger(__name__)


def convert_legacy_fhir_data_forward(apps, schema_editor):
    """
    Convert existing patient data from legacy cumulative_fhir_json format
    to the new hybrid encryption format with encrypted_fhir_bundle and 
    searchable metadata extraction.
    
    This migration:
    1. Copies cumulative_fhir_json to encrypted_fhir_bundle
    2. Extracts searchable metadata from FHIR resources
    3. Populates encounter_dates and provider_references
    4. Maintains data integrity and audit trails
    """
    Patient = apps.get_model('patients', 'Patient')
    PatientHistory = apps.get_model('patients', 'PatientHistory')
    
    total_patients = Patient.objects.count()
    logger.info(f"Starting hybrid encryption migration for {total_patients} patients")
    
    migrated_count = 0
    error_count = 0
    
    for patient in Patient.objects.all():
        try:
            # Check if patient has legacy FHIR data to migrate
            if not patient.cumulative_fhir_json or patient.cumulative_fhir_json == {}:
                logger.debug(f"Patient {patient.mrn} has no FHIR data to migrate")
                continue
            
            logger.info(f"Migrating patient {patient.mrn}")
            
            # Step 1: Copy cumulative_fhir_json to encrypted_fhir_bundle
            # The encrypt() field will automatically handle encryption
            patient.encrypted_fhir_bundle = patient.cumulative_fhir_json
            
            # Step 2: Initialize searchable metadata structures
            searchable_codes = {
                "conditions": [],
                "procedures": [],
                "medications": [],
                "observations": []
            }
            encounter_dates = []
            provider_references = []
            
            # Step 3: Extract searchable metadata from legacy FHIR data
            legacy_bundle = patient.cumulative_fhir_json
            
            # Handle both Bundle format and direct resource arrays
            if isinstance(legacy_bundle, dict):
                # Check if it's a FHIR Bundle
                if legacy_bundle.get("resourceType") == "Bundle" and "entry" in legacy_bundle:
                    entries = legacy_bundle.get("entry", [])
                elif "entry" in legacy_bundle:
                    # Direct entry format
                    entries = legacy_bundle.get("entry", [])
                else:
                    # Assume it's a resource collection by type
                    entries = []
                    for resource_type, resources in legacy_bundle.items():
                        if isinstance(resources, list):
                            for resource in resources:
                                entries.append({"resource": resource})
                        elif isinstance(resources, dict):
                            entries.append({"resource": resources})
            else:
                logger.warning(f"Unknown FHIR data format for patient {patient.mrn}")
                entries = []
            
            # Process each entry to extract metadata
            for entry in entries:
                resource = entry.get("resource", {})
                if not resource or not isinstance(resource, dict):
                    continue
                
                resource_type = resource.get("resourceType")
                if not resource_type:
                    continue
                
                try:
                    # Extract based on resource type
                    if resource_type == "Condition":
                        extract_condition_metadata(resource, searchable_codes)
                    elif resource_type == "Procedure":
                        extract_procedure_metadata(resource, searchable_codes)
                    elif resource_type in ["MedicationRequest", "MedicationStatement", "Medication"]:
                        extract_medication_metadata(resource, searchable_codes)
                    elif resource_type == "Observation":
                        extract_observation_metadata(resource, searchable_codes)
                    elif resource_type == "Encounter":
                        extract_encounter_metadata(resource, encounter_dates, provider_references)
                    
                    # Extract provider references from any resource
                    extract_provider_references(resource, provider_references)
                    
                except Exception as e:
                    logger.warning(f"Error extracting metadata from {resource_type} for patient {patient.mrn}: {e}")
                    continue
            
            # Step 4: Update patient with extracted metadata
            patient.searchable_medical_codes = searchable_codes
            patient.encounter_dates = list(set(encounter_dates))  # Remove duplicates
            patient.provider_references = list(set(provider_references))  # Remove duplicates
            
            # Save the patient with new data
            patient.save(update_fields=[
                'encrypted_fhir_bundle',
                'searchable_medical_codes', 
                'encounter_dates',
                'provider_references'
            ])
            
            # Step 5: Create audit trail for migration
            PatientHistory.objects.create(
                patient=patient,
                action="hybrid_encryption_migration",
                description=f"Migrated to hybrid encryption format. Extracted {len(searchable_codes.get('conditions', []))} conditions, {len(searchable_codes.get('procedures', []))} procedures, {len(searchable_codes.get('medications', []))} medications, {len(searchable_codes.get('observations', []))} observations, {len(encounter_dates)} encounters, {len(provider_references)} provider references.",
                fhir_delta={
                    "migration_stats": {
                        "conditions_extracted": len(searchable_codes.get("conditions", [])),
                        "procedures_extracted": len(searchable_codes.get("procedures", [])),
                        "medications_extracted": len(searchable_codes.get("medications", [])),
                        "observations_extracted": len(searchable_codes.get("observations", [])),
                        "encounters_extracted": len(encounter_dates),
                        "providers_extracted": len(provider_references)
                    }
                },
                created_by_id=None  # System migration
            )
            
            migrated_count += 1
            logger.info(f"Successfully migrated patient {patient.mrn}")
            
        except Exception as e:
            error_count += 1
            logger.error(f"Failed to migrate patient {patient.mrn}: {e}")
            continue
    
    logger.info(f"Migration completed: {migrated_count} patients migrated, {error_count} errors")


def convert_legacy_fhir_data_reverse(apps, schema_editor):
    """
    Reverse migration: restore data from encrypted_fhir_bundle back to cumulative_fhir_json.
    
    Note: This is a rollback operation and should be used with caution.
    """
    Patient = apps.get_model('patients', 'Patient')
    
    logger.info("Starting reverse migration from hybrid encryption format")
    
    for patient in Patient.objects.all():
        try:
            if patient.encrypted_fhir_bundle:
                # Copy encrypted data back to legacy field
                patient.cumulative_fhir_json = patient.encrypted_fhir_bundle
                
                # Clear the new fields (optional - keeps them for reference)
                # patient.searchable_medical_codes = {}
                # patient.encounter_dates = []
                # patient.provider_references = []
                
                patient.save(update_fields=['cumulative_fhir_json'])
                logger.info(f"Reversed migration for patient {patient.mrn}")
                
        except Exception as e:
            logger.error(f"Failed to reverse migration for patient {patient.mrn}: {e}")
            continue


# Helper functions for metadata extraction
def extract_condition_metadata(resource, searchable_codes):
    """Extract metadata from Condition resources."""
    if "code" in resource and "coding" in resource["code"]:
        for coding in resource["code"]["coding"]:
            code_data = {
                "system": coding.get("system"),
                "code": coding.get("code"),
                "display": coding.get("display"),
                "resourceId": resource.get("id")
            }
            
            # Add onset date if available (PHI-safe format)
            if "onsetDateTime" in resource:
                try:
                    onset_date = resource["onsetDateTime"][:10]  # YYYY-MM-DD only
                    code_data["onsetDate"] = onset_date
                except (IndexError, TypeError):
                    pass
            
            # Add clinical status if available
            if "clinicalStatus" in resource:
                clinical_status = resource["clinicalStatus"]
                if isinstance(clinical_status, dict):
                    code_data["clinicalStatus"] = clinical_status.get("text") or clinical_status.get("coding", [{}])[0].get("code")
            
            if code_data not in searchable_codes["conditions"]:
                searchable_codes["conditions"].append(code_data)


def extract_procedure_metadata(resource, searchable_codes):
    """Extract metadata from Procedure resources."""
    if "code" in resource and "coding" in resource["code"]:
        for coding in resource["code"]["coding"]:
            code_data = {
                "system": coding.get("system"),
                "code": coding.get("code"),
                "display": coding.get("display"),
                "resourceId": resource.get("id")
            }
            
            # Add performed date if available (PHI-safe format)
            if "performedDateTime" in resource:
                try:
                    performed_date = resource["performedDateTime"][:10]  # YYYY-MM-DD only
                    code_data["performedDate"] = performed_date
                except (IndexError, TypeError):
                    pass
            
            # Add status if available
            if "status" in resource:
                code_data["status"] = resource["status"]
            
            if code_data not in searchable_codes["procedures"]:
                searchable_codes["procedures"].append(code_data)


def extract_medication_metadata(resource, searchable_codes):
    """Extract metadata from Medication resources."""
    # Handle different medication resource types
    medication_coding = None
    
    if "medicationCodeableConcept" in resource and "coding" in resource["medicationCodeableConcept"]:
        medication_coding = resource["medicationCodeableConcept"]["coding"]
    elif "code" in resource and "coding" in resource["code"]:
        medication_coding = resource["code"]["coding"]
    
    if medication_coding:
        for coding in medication_coding:
            code_data = {
                "system": coding.get("system"),
                "code": coding.get("code"),
                "display": coding.get("display"),
                "resourceId": resource.get("id"),
                "resourceType": resource.get("resourceType")
            }
            
            # Add status if available
            if "status" in resource:
                code_data["status"] = resource["status"]
            
            # Add effective period if available (PHI-safe format)
            if "effectivePeriod" in resource:
                period = resource["effectivePeriod"]
                if "start" in period:
                    try:
                        code_data["effectiveStart"] = period["start"][:10]  # YYYY-MM-DD only
                    except (IndexError, TypeError):
                        pass
            
            if code_data not in searchable_codes["medications"]:
                searchable_codes["medications"].append(code_data)


def extract_observation_metadata(resource, searchable_codes):
    """Extract metadata from Observation resources."""
    if "code" in resource and "coding" in resource["code"]:
        for coding in resource["code"]["coding"]:
            code_data = {
                "system": coding.get("system"),
                "code": coding.get("code"),
                "display": coding.get("display"),
                "resourceId": resource.get("id")
            }
            
            # Add status if available
            if "status" in resource:
                code_data["status"] = resource["status"]
            
            # Add value information if available (PHI-safe)
            if "valueQuantity" in resource:
                value_qty = resource["valueQuantity"]
                code_data["value"] = {
                    "value": value_qty.get("value"),
                    "unit": value_qty.get("unit"),
                    "code": value_qty.get("code"),
                    "system": value_qty.get("system")
                }
            
            # Add effective date if available (PHI-safe format)
            if "effectiveDateTime" in resource:
                try:
                    code_data["effectiveDate"] = resource["effectiveDateTime"][:10]  # YYYY-MM-DD only
                except (IndexError, TypeError):
                    pass
            
            if code_data not in searchable_codes["observations"]:
                searchable_codes["observations"].append(code_data)


def extract_encounter_metadata(resource, encounter_dates, provider_references):
    """Extract metadata from Encounter resources."""
    # Extract encounter dates
    if "period" in resource and "start" in resource["period"]:
        try:
            encounter_date = resource["period"]["start"][:10]  # YYYY-MM-DD only
            if encounter_date not in encounter_dates:
                encounter_dates.append(encounter_date)
        except (IndexError, TypeError):
            pass
    
    # Extract provider references from participants
    if "participant" in resource:
        for participant in resource["participant"]:
            if "individual" in participant and "reference" in participant["individual"]:
                provider_ref = participant["individual"]["reference"]
                if provider_ref and provider_ref not in provider_references:
                    provider_references.append(provider_ref)


def extract_provider_references(resource, provider_references):
    """Extract provider references from any resource type."""
    # Common provider reference fields
    provider_fields = [
        "practitioner",
        "performer",
        "requester",
        "author",
        "asserter"
    ]
    
    for field in provider_fields:
        if field in resource:
            provider_data = resource[field]
            
            # Handle single reference
            if isinstance(provider_data, dict) and "reference" in provider_data:
                provider_ref = provider_data["reference"]
                if provider_ref and provider_ref not in provider_references:
                    provider_references.append(provider_ref)
            
            # Handle array of references
            elif isinstance(provider_data, list):
                for provider in provider_data:
                    if isinstance(provider, dict) and "reference" in provider:
                        provider_ref = provider["reference"]
                        if provider_ref and provider_ref not in provider_references:
                            provider_references.append(provider_ref)


class Migration(migrations.Migration):

    dependencies = [
        ('patients', '0004_add_dual_storage_fields'),
    ]

    operations = [
        migrations.RunPython(
            convert_legacy_fhir_data_forward,
            convert_legacy_fhir_data_reverse,
            hints={'patients': ['Patient', 'PatientHistory']}
        ),
    ]
