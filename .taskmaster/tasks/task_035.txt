# Task ID: 35
# Title: Implement Clinical Date Extraction and Manual Entry System
# Status: pending
# Dependencies: 5, 6, 14, 20, 30, 31
# Priority: high
# Description: Create a comprehensive system to handle clinical dates in FHIR resources while maintaining HIPAA audit compliance, including date extraction, manual entry, and clear distinction between processing metadata and clinical data.
# Details:
Implement the Clinical Date Extraction and Manual Entry System with the following components:

1. ClinicalDateParser utility:
```python
import re
from dateutil import parser
from transformers import pipeline

class ClinicalDateParser:
    def __init__(self):
        self.nlp_pipeline = pipeline("ner", model="emilyalsentzer/Bio_ClinicalBERT")

    def extract_dates(self, text):
        # Use regex for initial date extraction
        date_patterns = [
            r'\d{1,2}/\d{1,2}/\d{2,4}',
            r'\d{4}-\d{2}-\d{2}',
            r'\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]* \d{1,2},? \d{4}\b'
        ]
        extracted_dates = []
        for pattern in date_patterns:
            extracted_dates.extend(re.findall(pattern, text))

        # Use NLP for more complex date expressions
        entities = self.nlp_pipeline(text)
        for entity in entities:
            if entity['entity'] == 'DATE':
                extracted_dates.append(entity['word'])

        # Parse and standardize dates
        standardized_dates = []
        for date_str in extracted_dates:
            try:
                parsed_date = parser.parse(date_str)
                standardized_dates.append(parsed_date.strftime('%Y-%m-%d'))
            except ValueError:
                pass  # Skip unparseable dates

        return standardized_dates

# Usage
parser = ClinicalDateParser()
dates = parser.extract_dates("Patient was admitted on 05/15/2023 and discharged last Friday.")
```

2. Update FHIR services:
```python
# condition_service.py
from datetime import datetime
from .clinical_date_parser import ClinicalDateParser

class ConditionService:
    def __init__(self):
        self.date_parser = ClinicalDateParser()

    def create_condition(self, patient, condition_data):
        extracted_dates = self.date_parser.extract_dates(condition_data['description'])
        onset_date = extracted_dates[0] if extracted_dates else None

        condition = Condition(
            patient=patient,
            code=condition_data['code'],
            description=condition_data['description'],
            onset_date=onset_date,
            recorded_date=datetime.now()  # This is metadata, not clinical data
        )
        condition.save()
        return condition

# Similar updates for observation_service.py
```

3. Enhance ParsedData model:
```python
# documents/models.py
class ParsedData(models.Model):
    document = models.ForeignKey(Document, on_delete=models.CASCADE)
    field_name = models.CharField(max_length=100)
    field_value = models.TextField()
    confidence_score = models.FloatField()
    extracted_date = models.DateField(null=True, blank=True)
    is_clinical_date = models.BooleanField(default=False)
    manual_review_required = models.BooleanField(default=False)
```

4. Manual date entry interface:
```javascript
// date_entry.js
function validateDate(dateString) {
    const regex = /^\d{4}-\d{2}-\d{2}$/;
    if (!regex.test(dateString)) return false;
    const date = new Date(dateString);
    return date instanceof Date && !isNaN(date);
}

document.getElementById('dateForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const dateInput = document.getElementById('clinicalDate');
    if (validateDate(dateInput.value)) {
        // Submit date to server
        fetch('/api/submit-clinical-date', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({date: dateInput.value, parsedDataId: parsedDataId}),
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showSuccessMessage('Date submitted successfully');
            } else {
                showErrorMessage('Error submitting date');
            }
        });
    } else {
        showErrorMessage('Invalid date format. Please use YYYY-MM-DD.');
    }
});
```

5. API endpoints with HIPAA audit logging:
```python
# views.py
from .models import ParsedData
from .audit_log import log_audit_event

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def submit_clinical_date(request):
    parsed_data_id = request.data.get('parsedDataId')
    clinical_date = request.data.get('date')

    parsed_data = ParsedData.objects.get(id=parsed_data_id)
    parsed_data.extracted_date = clinical_date
    parsed_data.is_clinical_date = True
    parsed_data.save()

    log_audit_event(
        user=request.user,
        action='UPDATE',
        resource_type='ParsedData',
        resource_id=parsed_data_id,
        details=f"Updated clinical date to {clinical_date}"
    )

    return Response({'success': True})
```

6. Background task for missing dates:
```python
# tasks.py
from celery import shared_task
from .models import Document, ParsedData
from .clinical_date_parser import ClinicalDateParser

@shared_task
def identify_missing_clinical_dates():
    parser = ClinicalDateParser()
    documents = Document.objects.filter(processing_complete=True)
    
    for document in documents:
        parsed_data = ParsedData.objects.filter(document=document, is_clinical_date=True, extracted_date__isnull=True)
        
        for data in parsed_data:
            extracted_dates = parser.extract_dates(data.field_value)
            if extracted_dates:
                data.extracted_date = extracted_dates[0]
                data.save()
            else:
                data.manual_review_required = True
                data.save()

# Schedule this task to run periodically
```

7. Update patient timeline:
```python
# patient_service.py
def get_patient_timeline(patient):
    timeline = []
    
    # Fetch all date-related events
    conditions = Condition.objects.filter(patient=patient)
    observations = Observation.objects.filter(patient=patient)
    documents = Document.objects.filter(patient=patient)
    
    for condition in conditions:
        timeline.append({
            'date': condition.onset_date,
            'event_type': 'Condition',
            'description': condition.description,
            'is_clinical_date': True
        })
    
    for observation in observations:
        timeline.append({
            'date': observation.effective_date,
            'event_type': 'Observation',
            'description': observation.code.text,
            'is_clinical_date': True
        })
    
    for document in documents:
        timeline.append({
            'date': document.created_at,
            'event_type': 'Document',
            'description': f"Document uploaded: {document.title}",
            'is_clinical_date': False
        })
    
    # Sort timeline by date
    timeline.sort(key=lambda x: x['date'])
    
    return timeline
```

8. Implement date range filtering:
```python
# patient_search.py
def search_patients(query, date_range_start=None, date_range_end=None):
    patients = Patient.objects.filter(
        Q(first_name__icontains=query) | 
        Q(last_name__icontains=query) |
        Q(mrn__icontains=query)
    )
    
    if date_range_start and date_range_end:
        patients = patients.filter(
            Q(condition__onset_date__range=[date_range_start, date_range_end]) |
            Q(observation__effective_date__range=[date_range_start, date_range_end])
        ).distinct()
    
    return patients
```

This implementation provides a comprehensive system for handling clinical dates, including extraction, manual entry, and clear distinction between clinical and processing dates. It maintains HIPAA compliance through audit logging and integrates with existing FHIR resources and document processing workflows.

# Test Strategy:
To verify the correct implementation of the Clinical Date Extraction and Manual Entry System:

1. Unit test the ClinicalDateParser:
```python
def test_clinical_date_parser():
    parser = ClinicalDateParser()
    
    # Test various date formats
    assert parser.extract_dates("Patient admitted on 05/15/2023") == ["2023-05-15"]
    assert parser.extract_dates("Follow-up scheduled for January 10, 2024") == ["2024-01-10"]
    assert parser.extract_dates("No dates in this text") == []
    
    # Test complex date expressions
    assert parser.extract_dates("Symptoms started last week, worsened yesterday") != []
    
    # Test multiple dates in one text
    result = parser.extract_dates("Admitted on 2023-06-01, discharged on 06/15/2023")
    assert len(result) == 2 and "2023-06-01" in result and "2023-06-15" in result

2. Test FHIR service updates:
```python
def test_condition_service():
    service = ConditionService()
    patient = Patient.objects.create(mrn="TEST001")
    
    condition_data = {
        "code": "J45",
        "description": "Asthma exacerbation on 2023-07-01"
    }
    
    condition = service.create_condition(patient, condition_data)
    
    assert condition.onset_date == datetime.date(2023, 7, 1)
    assert condition.recorded_date.date() == datetime.date.today()

3. Verify ParsedData model changes:
```python
def test_parsed_data_model():
    document = Document.objects.create(title="Test Doc")
    parsed_data = ParsedData.objects.create(
        document=document,
        field_name="admission_date",
        field_value="2023-08-15",
        confidence_score=0.95,
        extracted_date="2023-08-15",
        is_clinical_date=True
    )
    
    assert parsed_data.is_clinical_date == True
    assert parsed_data.extracted_date == datetime.date(2023, 8, 15)

4. Test manual date entry interface:
- Use Selenium or a similar tool to simulate user interactions with the date entry form.
- Verify that client-side validation correctly handles valid and invalid date formats.
- Ensure the form submission process works as expected, including error handling.

5. API endpoint and HIPAA audit logging:
```python
def test_submit_clinical_date_api():
    client = APIClient()
    user = User.objects.create_user(username='testuser', password='testpass')
    client.force_authenticate(user=user)
    
    parsed_data = ParsedData.objects.create(field_name="test_date")
    
    response = client.post('/api/submit-clinical-date', {
        'parsedDataId': parsed_data.id,
        'date': '2023-09-01'
    })
    
    assert response.status_code == 200
    assert response.data['success'] == True
    
    updated_parsed_data = ParsedData.objects.get(id=parsed_data.id)
    assert updated_parsed_data.extracted_date == datetime.date(2023, 9, 1)
    assert updated_parsed_data.is_clinical_date == True
    
    # Verify audit log
    audit_log = AuditLog.objects.filter(
        user=user,
        action='UPDATE',
        resource_type='ParsedData',
        resource_id=str(parsed_data.id)
    ).first()
    
    assert audit_log is not None
    assert "Updated clinical date to 2023-09-01" in audit_log.details

6. Test background task for missing dates:
```python
from unittest.mock import patch

@patch('tasks.ClinicalDateParser')
def test_identify_missing_clinical_dates(mock_parser):
    mock_parser.return_value.extract_dates.return_value = ['2023-10-01']
    
    document = Document.objects.create(processing_complete=True)
    parsed_data = ParsedData.objects.create(
        document=document,
        field_name="test_date",
        field_value="October 1, 2023",
        is_clinical_date=True
    )
    
    identify_missing_clinical_dates()
    
    updated_parsed_data = ParsedData.objects.get(id=parsed_data.id)
    assert updated_parsed_data.extracted_date == datetime.date(2023, 10, 1)

7. Verify patient timeline updates:
```python
def test_patient_timeline():
    patient = Patient.objects.create(mrn="TEST002")
    condition = Condition.objects.create(
        patient=patient,
        description="Test Condition",
        onset_date="2023-11-01"
    )
    observation = Observation.objects.create(
        patient=patient,
        code=CodeableConcept.objects.create(text="Test Observation"),
        effective_date="2023-11-15"
    )
    document = Document.objects.create(
        patient=patient,
        title="Test Document",
        created_at="2023-11-30"
    )
    
    timeline = get_patient_timeline(patient)
    
    assert len(timeline) == 3
    assert timeline[0]['date'] == datetime.date(2023, 11, 1)
    assert timeline[0]['is_clinical_date'] == True
    assert timeline[2]['date'] == datetime.date(2023, 11, 30)
    assert timeline[2]['is_clinical_date'] == False

8. Test date range filtering in patient search:
```python
def test_patient_search_with_date_range():
    patient1 = Patient.objects.create(first_name="John", last_name="Doe")
    patient2 = Patient.objects.create(first_name="Jane", last_name="Doe")
    
    Condition.objects.create(patient=patient1, onset_date="2023-12-01")
    Observation.objects.create(patient=patient2, effective_date="2023-12-15")
    
    results = search_patients("Doe", date_range_start="2023-12-01", date_range_end="2023-12-31")
    
    assert len(results) == 2
    
    results = search_patients("Doe", date_range_start="2023-12-01", date_range_end="2023-12-10")
    
    assert len(results) == 1
    assert results[0] == patient1

9. Integration Testing:
- Perform end-to-end testing of the entire clinical date workflow, from document upload to data extraction, manual review, and integration into patient records.
- Verify that the system correctly distinguishes between clinical dates and processing metadata throughout the entire process.

10. Performance Testing:
- Test the system with a large volume of documents and patient data to ensure it can handle the expected load.
- Measure the performance of the date extraction process and optimize if necessary.

11. Security and Compliance Testing:
- Conduct penetration testing to ensure the security of the clinical date handling system.
- Verify that all date-related operations are properly logged for HIPAA compliance.
- Test access controls to ensure that only authorized users can view and modify clinical dates.

12. User Acceptance Testing:
- Engage with end-users (e.g., healthcare providers, data entry staff) to test the manual date entry interface and overall workflow.
- Gather feedback on the usability and efficiency of the new system compared to the previous approach.

# Subtasks:
## 1. Implement ClinicalDateParser utility [done]
### Dependencies: None
### Description: Create a utility class for extracting and parsing clinical dates from structured data and document text.
### Details:
Develop the ClinicalDateParser class with methods for date extraction, parsing, and validation. Include NLP techniques for identifying dates in text and handling various date formats.
<info added on 2025-09-26T04:28:31.960Z>
## Implementation Summary
Successfully implemented a comprehensive ClinicalDateParser utility class in `apps/core/date_parser.py` with the following features:

### Key Components Implemented:
1. **DateExtractionResult Class**: Container for extraction results with metadata (confidence, method, position)
2. **ClinicalDateParser Class**: Main parser with regex and fuzzy parsing capabilities
3. **Multiple Date Format Support**: 
   - ISO format (YYYY-MM-DD)
   - US format (MM/DD/YYYY, MM-DD-YYYY, MM.DD.YYYY)
   - Month names (January 15, 2023, 15 January 2023)
   - Two-digit years with intelligent century handling

### Advanced Features:
- **Confidence Scoring**: Each extracted date gets a confidence score (0.0-1.0)
- **Context Extraction**: Captures surrounding text for review interfaces
- **Deduplication**: Smart deduplication based on proximity and confidence
- **Clinical Date Validation**: Ensures dates are within reasonable medical range (1900-future appointments)
- **Multiple Extraction Methods**: Regex-based and fuzzy parsing with dateutil
- **Standardization**: Converts any valid date input to ISO format

### Implementation Highlights:
- Used existing `python-dateutil` dependency (no new packages needed)
- Comprehensive error handling for malformed dates
- Performance-optimized with compiled regex patterns
- Modular design for easy extension
- Clear separation of concerns

### Testing:
- **25 comprehensive unit tests** covering all functionality
- Edge cases and malformed date handling
- Realistic medical document examples
- All tests passing

### Files Created:
- `apps/core/date_parser.py` - Main parser implementation (400+ lines)
- `apps/core/tests/test_date_parser.py` - Comprehensive test suite (350+ lines)
- `apps/core/tests/__init__.py` - Test module initialization

### Usage Example:
```python
from apps.core.date_parser import ClinicalDateParser

parser = ClinicalDateParser()
results = parser.extract_dates("Patient admitted on 05/15/2023 and discharged May 20, 2023")
# Returns DateExtractionResult objects with dates, confidence, and context
```

Ready for integration into subtask 35.2 (FHIR services) and 35.3 (document processing).
</info added on 2025-09-26T04:28:31.960Z>

## 2. Update FHIR services for clinical date support [done]
### Dependencies: 35.1
### Description: Modify FHIR services to use clinical dates instead of processing timestamps and add support for optional clinical date parameters.
### Details:
Update condition_service.py and observation_service.py to remove datetime.now() usage for clinical dates. Add support for optional clinical_date parameter in create methods. Implement clear separation between clinical dates and processing metadata.

## 3. Enhance document processing workflow for date extraction [pending]
### Dependencies: 35.1, 35.2
### Description: Integrate ClinicalDateParser into the document processing pipeline and update AI extraction prompt for clinical dates.
### Details:
Modify the document processing workflow to use ClinicalDateParser for extracting dates. Update the AI extraction prompt to specifically request clinical dates. Store extracted dates in the ParsedData model.

## 4. Update database models for date entry status [pending]
### Dependencies: 35.3
### Description: Enhance existing models to track the status of clinical date entries and their sources.
### Details:
Modify the ParsedData model to include fields for clinical_date, date_source (extracted/manual), and date_status (pending/verified). Update related models as necessary to support these changes.

## 5. Implement review interface for manual date entry [pending]
### Dependencies: 35.4
### Description: Update the review interface to allow manual entry and editing of clinical dates.
### Details:
Add date input fields to the review form for each extracted data point. Implement client-side date validation and user-friendly date selection widgets. Ensure clear distinction between extracted and manually entered dates.

## 6. Create API endpoints for date submission and validation [pending]
### Dependencies: 35.4, 35.5
### Description: Implement API endpoints for submitting and validating clinical dates, with HIPAA-compliant audit logging.
### Details:
Develop RESTful API endpoints for updating clinical dates, including validation using ClinicalDateParser. Implement HIPAA-compliant audit logging for all clinical date changes. Extend the existing AuditLog model to include clinical date modifications.

## 7. Update FHIR resource creation process [pending]
### Dependencies: 35.2, 35.6
### Description: Modify the document finalization process to incorporate extracted or manually entered clinical dates into FHIR resources.
### Details:
Update the FHIR resource creation logic to use the clinical dates stored in ParsedData when available. Implement fallback logic for cases where clinical dates are missing. Ensure clear distinction between clinical dates and processing metadata in the resulting FHIR resources.

## 8. Implement comprehensive testing and HIPAA compliance validation [pending]
### Dependencies: 35.1, 35.2, 35.3, 35.4, 35.5, 35.6, 35.7
### Description: Conduct thorough testing of the entire clinical date system and validate HIPAA compliance across all components.
### Details:
Develop a comprehensive test suite covering all aspects of the clinical date extraction and manual entry system. Include unit tests, integration tests, and end-to-end tests. Perform HIPAA compliance audits on all components, especially focusing on data handling, storage, and audit logging.

