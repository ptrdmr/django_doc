# Task ID: 31
# Title: Update Document Review Interface for Snippet-Based Review
# Status: done
# Dependencies: 13, 30
# Priority: high
# Description: Replace the PDF highlighting approach with a text snippet-based review system that displays extracted data alongside source text context for more efficient document review. Remove PDF.js viewer completely and implement a single-column layout focused on snippet-based review.
# Details:
Implement the snippet-based document review interface with the following components:

1. Update DocumentReviewView to handle snippet data:
```python
class DocumentReviewView(LoginRequiredMixin, View):
    def get(self, request, document_id):
        document = get_object_or_404(Document, id=document_id)
        parsed_data = document.parsed_data.all().prefetch_related('source_snippets')
        
        # Group data by category for organized display
        categorized_data = defaultdict(list)
        for item in parsed_data:
            categorized_data[item.category].append({
                'field_name': item.field_name,
                'field_value': item.field_value,
                'confidence': item.confidence_score,
                'snippet': item.source_snippets.get('text', ''),
                'approved': item.is_approved,
                'id': item.id
            })
            
        context = {
            'document': document,
            'categorized_data': dict(categorized_data),
            'review_progress': document.get_review_progress()
        }
        return render(request, 'documents/review.html', context)
```

2. Modify the review.html template to use a single-column layout with no PDF viewer:
```html
{% extends "base.html" %}
{% block content %}
<div class="document-review-container">
  <div class="review-header">
    <h2>Review Document: {{ document.title }}</h2>
    <div class="progress-indicator">
      <div class="progress-bar" style="width: {{ review_progress }}%"></div>
      <span>{{ review_progress }}% Reviewed</span>
    </div>
  </div>
  
  {% if missing_fields %}
  <div class="missing-data-alert">
    <h3>Missing Data Alert</h3>
    <p>The following fields may be missing from this document:</p>
    <div class="missing-fields-list">
      {% for field in missing_fields %}
        <div class="missing-field-item">
          <span>{{ field.name }}</span>
          <button class="add-missing-field" data-field="{{ field.name }}">Add</button>
        </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}
  
  <div class="review-content">
    {% for category, items in categorized_data.items %}
      <div class="category-section">
        <h3>{{ category }}</h3>
        
        {% for item in items %}
          <div class="field-review-card" data-field-id="{{ item.id }}">
            <div class="field-header">
              <span class="field-name">{{ item.field_name }}</span>
              <span class="confidence-indicator confidence-{{ item.confidence|confidence_level }}">
                {{ item.confidence|confidence_level|title }} Confidence
              </span>
            </div>
            
            <div class="field-content">
              <div class="extracted-value">
                <h4>Extracted Value:</h4>
                <div class="value-display {% if item.approved %}approved{% endif %}">
                  {{ item.field_value }}
                </div>
                <div class="inline-editor" style="display: none;">
                  <input type="text" class="edit-field-value" value="{{ item.field_value }}">
                  <button class="save-edit">Save</button>
                  <button class="cancel-edit">Cancel</button>
                </div>
              </div>
              
              <div class="source-snippet">
                <h4>Source Context:</h4>
                <div class="snippet-text">{{ item.snippet }}</div>
              </div>
            </div>
            
            <div class="field-actions">
              <button class="approve-btn {% if item.approved %}approved{% endif %}" 
                      hx-post="{% url 'approve_field' item.id %}" 
                      hx-swap="outerHTML">
                {% if item.approved %}Approved{% else %}Approve{% endif %}
              </button>
              <button class="edit-btn">Edit</button>
              <button class="flag-btn" hx-post="{% url 'flag_field' item.id %}">Flag for Review</button>
            </div>
          </div>
        {% endfor %}
      </div>
    {% endfor %}
  </div>
  
  <div class="review-actions">
    <button class="complete-review-btn" hx-post="{% url 'complete_review' document.id %}" 
            hx-confirm="Are you sure you want to complete this review?">
      Complete Review
    </button>
    <button class="request-reprocessing-btn">Request Reprocessing</button>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Inline editing functionality
    document.querySelectorAll('.edit-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const card = this.closest('.field-review-card');
        const valueDisplay = card.querySelector('.value-display');
        const editor = card.querySelector('.inline-editor');
        
        valueDisplay.style.display = 'none';
        editor.style.display = 'block';
      });
    });
    
    document.querySelectorAll('.cancel-edit').forEach(btn => {
      btn.addEventListener('click', function() {
        const card = this.closest('.field-review-card');
        const valueDisplay = card.querySelector('.value-display');
        const editor = card.querySelector('.inline-editor');
        
        valueDisplay.style.display = 'block';
        editor.style.display = 'none';
      });
    });
    
    document.querySelectorAll('.save-edit').forEach(btn => {
      btn.addEventListener('click', function() {
        const card = this.closest('.field-review-card');
        const fieldId = card.dataset.fieldId;
        const newValue = card.querySelector('.edit-field-value').value;
        
        htmx.ajax('POST', `/documents/field/${fieldId}/update/`, {
          values: { value: newValue },
          target: card,
          swap: 'outerHTML'
        });
      });
    });
    
    // Add missing field functionality
    document.querySelectorAll('.add-missing-field').forEach(btn => {
      btn.addEventListener('click', function() {
        const fieldName = this.dataset.field;
        const documentId = {{ document.id }};
        
        htmx.ajax('POST', `/documents/${documentId}/add-field/`, {
          values: { field_name: fieldName },
          target: this.closest('.category-section'),
          swap: 'beforeend'
        });
      });
    });
  });
</script>
{% endblock %}
```

3. Implement field-level action endpoints:

```python
@require_POST
def approve_field(request, field_id):
    field = get_object_or_404(ParsedData, id=field_id)
    field.is_approved = True
    field.approved_by = request.user
    field.approved_at = timezone.now()
    field.save()
    
    # Return updated field card HTML
    return render(request, 'documents/partials/field_card.html', {'item': {
        'field_name': field.field_name,
        'field_value': field.field_value,
        'confidence': field.confidence_score,
        'snippet': field.source_snippets.get('text', ''),
        'approved': field.is_approved,
        'id': field.id
    }})

@require_POST
def update_field_value(request, field_id):
    field = get_object_or_404(ParsedData, id=field_id)
    field.field_value = request.POST.get('value')
    field.edited_by = request.user
    field.edited_at = timezone.now()
    field.save()
    
    # Return updated field card HTML
    return render(request, 'documents/partials/field_card.html', {'item': {
        'field_name': field.field_name,
        'field_value': field.field_value,
        'confidence': field.confidence_score,
        'snippet': field.source_snippets.get('text', ''),
        'approved': field.is_approved,
        'id': field.id
    }})

@require_POST
def flag_field(request, field_id):
    field = get_object_or_404(ParsedData, id=field_id)
    field.is_flagged = True
    field.flagged_by = request.user
    field.flagged_at = timezone.now()
    field.flag_reason = request.POST.get('reason', '')
    field.save()
    
    # Return updated field card HTML
    return render(request, 'documents/partials/field_card.html', {'item': {
        'field_name': field.field_name,
        'field_value': field.field_value,
        'confidence': field.confidence_score,
        'snippet': field.source_snippets.get('text', ''),
        'approved': field.is_approved,
        'flagged': field.is_flagged,
        'id': field.id
    }})
```

4. Add confidence indicator template filter:

```python
@register.filter
def confidence_level(score):
    if score >= 0.8:
        return "high"
    elif score >= 0.5:
        return "medium"
    else:
        return "low"
```

5. Create CSS for the new single-column interface:

```css
/* Document Review Styles */
.document-review-container {
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
}

.review-header {
  margin-bottom: 30px;
}

.progress-indicator {
  height: 20px;
  background-color: #f0f0f0;
  border-radius: 10px;
  margin-top: 10px;
  position: relative;
}

.progress-bar {
  height: 100%;
  background-color: #4CAF50;
  border-radius: 10px;
  transition: width 0.3s ease;
}

.missing-data-alert {
  background-color: #fff3e0;
  border-left: 4px solid #ff9800;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 4px;
}

.category-section {
  margin-bottom: 30px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 15px;
}

.field-review-card {
  background-color: white;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  padding: 15px;
  margin-bottom: 15px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.field-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
}

.field-name {
  font-weight: bold;
  font-size: 16px;
}

.confidence-indicator {
  padding: 3px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.confidence-high {
  background-color: #e8f5e9;
  color: #2e7d32;
}

.confidence-medium {
  background-color: #fff8e1;
  color: #ff8f00;
}

.confidence-low {
  background-color: #ffebee;
  color: #c62828;
}

.field-content {
  display: flex;
  flex-direction: column;
  margin-bottom: 15px;
}

.extracted-value, .source-snippet {
  padding: 10px;
  margin-bottom: 10px;
}

.source-snippet {
  background-color: #f5f5f5;
  border-radius: 4px;
}

.snippet-text {
  font-family: monospace;
  white-space: pre-wrap;
  padding: 10px;
  background-color: #f8f9fa;
  border-left: 3px solid #007bff;
}

.field-actions {
  display: flex;
  gap: 10px;
}

.approve-btn, .edit-btn, .flag-btn {
  padding: 8px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.approve-btn {
  background-color: #4CAF50;
  color: white;
}

.approve-btn.approved {
  background-color: #81c784;
}

.edit-btn {
  background-color: #2196F3;
  color: white;
}

.flag-btn {
  background-color: #FFC107;
  color: #212121;
}

.missing-fields-section {
  margin-top: 20px;
  padding: 10px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.missing-field-item {
  display: flex;
  justify-content: space-between;
  padding: 8px;
  border-bottom: 1px solid #e0e0e0;
}

.review-actions {
  margin-top: 30px;
  display: flex;
  justify-content: flex-end;
  gap: 15px;
}

.complete-review-btn, .request-reprocessing-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.complete-review-btn {
  background-color: #4CAF50;
  color: white;
}

.request-reprocessing-btn {
  background-color: #f44336;
  color: white;
}

.inline-editor {
  margin-top: 10px;
}

.edit-field-value {
  width: 100%;
  padding: 8px;
  margin-bottom: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.value-display.approved {
  border-left: 4px solid #4CAF50;
  padding-left: 8px;
}
```

6. Update URLs configuration:

```python
urlpatterns = [
    # Existing URLs
    path('documents/<int:document_id>/review/', DocumentReviewView.as_view(), name='document_review'),
    path('documents/field/<int:field_id>/approve/', approve_field, name='approve_field'),
    path('documents/field/<int:field_id>/update/', update_field_value, name='update_field_value'),
    path('documents/field/<int:field_id>/flag/', flag_field, name='flag_field'),
    path('documents/<int:document_id>/complete-review/', complete_review, name='complete_review'),
    path('documents/<int:document_id>/add-field/', add_missing_field, name='add_missing_field'),
]
```

7. Implement the complete review endpoint:

```python
@require_POST
def complete_review(request, document_id):
    document = get_object_or_404(Document, id=document_id)
    
    # Check if all fields are reviewed
    unreviewed_fields = document.parsed_data.filter(is_approved=False, is_flagged=False).count()
    if unreviewed_fields > 0:
        messages.warning(request, f"There are still {unreviewed_fields} unreviewed fields.")
        return redirect('document_review', document_id=document_id)
    
    # Update document status
    document.status = Document.STATUS_REVIEWED
    document.reviewed_by = request.user
    document.reviewed_at = timezone.now()
    document.save()
    
    # Trigger FHIR integration if configured to do so automatically
    if settings.AUTO_INTEGRATE_AFTER_REVIEW:
        from documents.tasks import integrate_document_data
        integrate_document_data.delay(document_id)
        messages.success(request, "Document review completed. FHIR integration started.")
    else:
        messages.success(request, "Document review completed successfully.")
    
    return redirect('document_list')
```

8. Create a partial template for the field card to support HTMX updates:

```html
<!-- documents/partials/field_card.html -->
<div class="field-review-card" data-field-id="{{ item.id }}">
  <div class="field-header">
    <span class="field-name">{{ item.field_name }}</span>
    <span class="confidence-indicator confidence-{{ item.confidence|confidence_level }}">
      {{ item.confidence|confidence_level|title }} Confidence
    </span>
  </div>
  
  <div class="field-content">
    <div class="extracted-value">
      <h4>Extracted Value:</h4>
      <div class="value-display {% if item.approved %}approved{% endif %}">
        {{ item.field_value }}
      </div>
      <div class="inline-editor" style="display: none;">
        <input type="text" class="edit-field-value" value="{{ item.field_value }}">
        <button class="save-edit">Save</button>
        <button class="cancel-edit">Cancel</button>
      </div>
    </div>
    
    <div class="source-snippet">
      <h4>Source Context:</h4>
      <div class="snippet-text">{{ item.snippet }}</div>
    </div>
  </div>
  
  <div class="field-actions">
    <button class="approve-btn {% if item.approved %}approved{% endif %}" 
            hx-post="{% url 'approve_field' item.id %}" 
            hx-swap="outerHTML">
      {% if item.approved %}Approved{% else %}Approve{% endif %}
    </button>
    <button class="edit-btn">Edit</button>
    <button class="flag-btn" hx-post="{% url 'flag_field' item.id %}">Flag for Review</button>
  </div>
</div>
```

This implementation completely removes the PDF.js viewer and replaces the two-column layout with a single-column review layout focused on snippet-based review. The interface follows a clean, simple structure with: Header → Missing Data Alert → Extracted Fields List → Action Buttons. This aligns with Phase 2 of the original plan to remove PDF.js dependencies and create a more streamlined review experience.

# Test Strategy:
To verify the correct implementation of the snippet-based document review interface:

1. Unit Tests:
```python
class DocumentReviewViewTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testuser', password='password')
        self.client.login(username='testuser', password='password')
        self.document = Document.objects.create(title="Test Document", status=Document.STATUS_PROCESSED)
        
        # Create parsed data with snippets
        self.parsed_data1 = ParsedData.objects.create(
            document=self.document,
            field_name="Patient Name",
            field_value="John Doe",
            confidence_score=0.95,
            category="Demographics",
            source_snippets={"text": "Patient: John Doe DOB: 01/15/1980"}
        )
        
        self.parsed_data2 = ParsedData.objects.create(
            document=self.document,
            field_name="Diagnosis",
            field_value="Hypertension",
            confidence_score=0.75,
            category="Medical",
            source_snippets={"text": "Assessment: Patient has uncontrolled hypertension"}
        )
    
    def test_document_review_view_loads(self):
        response = self.client.get(reverse('document_review', args=[self.document.id]))
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed(response, 'documents/review.html')
        self.assertContains(response, "John Doe")
        self.assertContains(response, "Hypertension")
        
    def test_approve_field(self):
        response = self.client.post(reverse('approve_field', args=[self.parsed_data1.id]))
        self.assertEqual(response.status_code, 200)
        self.parsed_data1.refresh_from_db()
        self.assertTrue(self.parsed_data1.is_approved)
        
    def test_update_field_value(self):
        response = self.client.post(
            reverse('update_field_value', args=[self.parsed_data1.id]),
            {'value': 'Jane Doe'}
        )
        self.assertEqual(response.status_code, 200)
        self.parsed_data1.refresh_from_db()
        self.assertEqual(self.parsed_data1.field_value, 'Jane Doe')
        
    def test_flag_field(self):
        response = self.client.post(
            reverse('flag_field', args=[self.parsed_data1.id]),
            {'reason': 'Needs verification'}
        )
        self.assertEqual(response.status_code, 200)
        self.parsed_data1.refresh_from_db()
        self.assertTrue(self.parsed_data1.is_flagged)
        
    def test_complete_review_with_unreviewed_fields(self):
        response = self.client.post(reverse('complete_review', args=[self.document.id]))
        self.assertEqual(response.status_code, 302)  # Redirect
        self.document.refresh_from_db()
        self.assertNotEqual(self.document.status, Document.STATUS_REVIEWED)  # Should not be marked as reviewed
        
    def test_complete_review_success(self):
        # Approve all fields first
        self.client.post(reverse('approve_field', args=[self.parsed_data1.id]))
        self.client.post(reverse('approve_field', args=[self.parsed_data2.id]))
        
        response = self.client.post(reverse('complete_review', args=[self.document.id]))
        self.assertEqual(response.status_code, 302)  # Redirect
        self.document.refresh_from_db()
        self.assertEqual(self.document.status, Document.STATUS_REVIEWED)
```

2. Integration Tests:
```python
class DocumentReviewIntegrationTests(TestCase):
    def setUp(self):
        # Similar setup as unit tests but with more realistic data
        pass
        
    def test_end_to_end_review_workflow(self):
        # Login
        self.client.login(username='testuser', password='password')
        
        # Navigate to document list
        response = self.client.get(reverse('document_list'))
        self.assertEqual(response.status_code, 200)
        
        # Click on review button for a document
        response = self.client.get(reverse('document_review', args=[self.document.id]))
        self.assertEqual(response.status_code, 200)
        
        # Approve some fields
        response = self.client.post(reverse('approve_field', args=[self.parsed_data1.id]))
        self.assertEqual(response.status_code, 200)
        
        # Edit a field
        response = self.client.post(
            reverse('update_field_value', args=[self.parsed_data2.id]),
            {'value': 'Updated Value'}
        )
        self.assertEqual(response.status_code, 200)
        
        # Flag a field
        response = self.client.post(
            reverse('flag_field', args=[self.parsed_data3.id]),
            {'reason': 'Needs verification'}
        )
        self.assertEqual(response.status_code, 200)
        
        # Complete the review
        response = self.client.post(reverse('complete_review', args=[self.document.id]))
        self.assertEqual(response.status_code, 302)  # Redirect
```

3. UI Testing:
   - Verify that the single-column layout renders correctly without any PDF viewer components
   - Test that the interface follows the structure: Header → Missing Data Alert → Extracted Fields List → Action Buttons
   - Manually test the interface in different browsers (Chrome, Firefox, Safari)
   - Verify that all UI elements render correctly
   - Test responsive design on different screen sizes
   - Verify that confidence indicators show correct colors
   - Test that inline editing works properly
   - Verify that source snippets display correctly

4. Performance Testing:
   - Test with documents containing large numbers of fields (100+)
   - Measure page load time and optimize if necessary
   - Test with concurrent users reviewing different documents
   - Verify improved performance without PDF.js loading overhead

5. Accessibility Testing:
   - Verify that the interface is accessible to screen readers
   - Test keyboard navigation
   - Ensure color contrast meets WCAG standards

6. User Acceptance Testing:
   - Have actual users test the interface with real documents
   - Collect feedback on usability and make adjustments as needed
   - Verify that the workflow is intuitive and efficient
   - Confirm that users can effectively review documents without the PDF viewer

# Subtasks:
## 1. Remove PDF.js Dependencies from Templates [done]
### Dependencies: None
### Description: Remove all PDF.js related code, imports, and dependencies from the document review template and any related templates.
### Details:
Search through all templates for PDF.js related code and remove it. This includes script imports, canvas elements, PDF viewer containers, and any related HTML structure. Focus on the review.html template and any other templates that might include PDF.js components.

## 2. Update DocumentReviewView to Handle Snippet Data [done]
### Dependencies: None
### Description: Modify the DocumentReviewView to fetch and organize document data with source snippets for the new snippet-based review interface.
### Details:
Implement the DocumentReviewView class to fetch document data, parsed data with snippets, and organize it by category. Include prefetch_related for source_snippets to optimize database queries. Structure the data in a format suitable for the template.

## 3. Create Single-Column Layout Structure [done]
### Dependencies: 31.1
### Description: Implement the basic HTML structure for the single-column layout in the review.html template.
### Details:
Create the main container structure for the document review page with sections for the header, progress indicator, review content, and action buttons. Remove any multi-column layouts and ensure the page follows a single-column flow.

## 4. Implement Review Header and Progress Indicator [done]
### Dependencies: 31.3
### Description: Create the review header section with document title and progress indicator.
### Details:
Implement the review header with document title and a progress bar that shows the percentage of reviewed fields. The progress bar should update based on the review_progress context variable.

## 5. Implement Missing Data Alert Component [done]
### Dependencies: 31.3
### Description: Create the missing data alert section that displays potentially missing fields in the document.
### Details:
Implement the missing data alert component that shows fields that might be missing from the document. Include functionality to add these fields if needed. This should be conditionally displayed only when missing fields are detected.

## 6. Implement Category Section Component [done]
### Dependencies: 31.3
### Description: Create the category section component that groups fields by category.
### Details:
Implement the category section component that displays a heading for each category and contains the field review cards for that category. This should iterate through the categorized_data context variable.

## 7. Implement Field Review Card Component [done]
### Dependencies: 31.6
### Description: Create the field review card component that displays field data and source snippet.
### Details:
Implement the field review card component that shows the field name, confidence indicator, extracted value, source snippet, and action buttons. This is the core component of the snippet-based review interface.

## 8. Create Field Card Partial Template [done]
### Dependencies: 31.7
### Description: Create a separate partial template for the field card to support HTMX updates.
### Details:
Extract the field review card HTML into a separate partial template (field_card.html) that can be rendered independently for HTMX updates. This should contain all the elements of the field review card.

## 9. Implement Approve Field Endpoint [done]
### Dependencies: 31.8
### Description: Create the endpoint for approving a field.
### Details:
Implement the approve_field view function that handles POST requests to approve a field. This should update the field's approval status and return the updated field card HTML.

## 10. Implement Update Field Value Endpoint [done]
### Dependencies: 31.8
### Description: Create the endpoint for updating a field's value.
### Details:
Implement the update_field_value view function that handles POST requests to update a field's value. This should save the new value and return the updated field card HTML.

## 11. Implement Flag Field Endpoint [done]
### Dependencies: 31.8
### Description: Create the endpoint for flagging a field for review.
### Details:
Implement the flag_field view function that handles POST requests to flag a field for review. This should update the field's flagged status and return the updated field card HTML.

## 12. Implement Complete Review Endpoint [done]
### Dependencies: 31.9, 31.10, 31.11
### Description: Create the endpoint for completing the document review.
### Details:
Implement the complete_review view function that handles POST requests to complete the document review. This should check if all fields are reviewed, update the document status, and redirect to the document list.

## 13. Implement Add Missing Field Endpoint [done]
### Dependencies: 31.5
### Description: Create the endpoint for adding a missing field.
### Details:
Implement the add_missing_field view function that handles POST requests to add a missing field. This should create a new ParsedData object and return the HTML for the new field card.

## 14. Implement Inline Editing JavaScript [done]
### Dependencies: 31.7
### Description: Create the JavaScript for inline editing of field values.
### Details:
Implement the JavaScript that handles showing/hiding the inline editor, canceling edits, and saving edits. This should include event listeners for the edit, cancel, and save buttons.

## 15. Implement Missing Field JavaScript [done]
### Dependencies: 31.5, 31.13
### Description: Create the JavaScript for adding missing fields.
### Details:
Implement the JavaScript that handles adding missing fields. This should include event listeners for the add buttons in the missing data alert.

## 16. Implement Base CSS Styles [done]
### Dependencies: 31.3
### Description: Create the base CSS styles for the document review interface.
### Details:
Implement the base CSS styles for the document review container, review header, progress indicator, and overall layout. This should establish the foundation for the single-column layout.

## 17. Implement Component-Specific CSS [done]
### Dependencies: 31.16
### Description: Create the CSS styles for specific components of the document review interface.
### Details:
Implement the CSS styles for specific components including the missing data alert, category sections, field review cards, source snippets, and action buttons. This should make each component visually distinct and user-friendly.

## 18. Implement Confidence Indicator Template Filter [done]
### Dependencies: 31.7
### Description: Create the template filter for displaying confidence levels.
### Details:
Implement the confidence_level template filter that converts a numeric confidence score into a text label (high, medium, low). This should be used to display the confidence indicator in the field review card.

